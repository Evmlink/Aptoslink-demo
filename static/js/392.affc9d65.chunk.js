"use strict";(self.webpackChunkaptoslink_example=self.webpackChunkaptoslink_example||[]).push([[392],{76392:(t,i,n)=>{n.r(i),n.d(i,{PhantomAdapter:()=>c});var e=n(20240),a=n(29314),s=n(44879),o=n(86319);function r(t,i,n){return new Promise(((e,a)=>{n>0?setTimeout((async()=>{const s=await t();s&&e(s),s||r(t,i,n-1).then((t=>(e(t),t))).catch((t=>a(t)))}),i):e(!1)}))}const h=async function(){var t;let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{interval:1e3,count:3};if("undefined"!==typeof window&&!(null===(t=window.solana)||void 0===t||!t.isPhantom))return window.solana;return await r((()=>{var t;return null===(t=window.solana)||void 0===t?void 0:t.isPhantom}),i.interval,i.count)?window.solana:null};class c extends s.v{constructor(){super(...arguments),(0,e.Z)(this,"name",a.rW.PHANTOM),(0,e.Z)(this,"adapterNamespace",a.yk.SOLANA),(0,e.Z)(this,"currentChainNamespace",a.EN.SOLANA),(0,e.Z)(this,"type",a.hN.EXTERNAL),(0,e.Z)(this,"status",a.MP.NOT_READY),(0,e.Z)(this,"_wallet",null),(0,e.Z)(this,"phantomProvider",null),(0,e.Z)(this,"_onDisconnect",(()=>{this._wallet&&(this._wallet.off("disconnect",this._onDisconnect),this.rehydrated=!1,this.status=this.status===a.MP.CONNECTED?a.MP.READY:a.MP.NOT_READY,this.emit(a.n2.DISCONNECTED))}))}get isWalletConnected(){var t;return!(null===(t=this._wallet)||void 0===t||!t.isConnected||this.status!==a.MP.CONNECTED)}get provider(){return this.status!==a.MP.NOT_READY&&this.phantomProvider?this.phantomProvider:null}set provider(t){throw new Error("Not implemented")}async init(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(await super.init(t),super.checkInitializationRequirements(),this._wallet=await h({interval:500,count:3}),!this._wallet)throw a.Ty.notInstalled();this.phantomProvider=new o.PhantomInjectedProvider({config:{chainConfig:this.chainConfig}}),this.status=a.MP.READY,this.emit(a.n2.READY,a.rW.PHANTOM);try{a.cM.debug("initializing phantom adapter"),t.autoConnect&&(this.rehydrated=!0,await this.connect())}catch(i){a.cM.error("Failed to connect with cached phantom provider",i),this.emit("ERRORED",i)}}async connect(){var t=this;try{if(super.checkConnectionRequirements(),this.status=a.MP.CONNECTING,this.emit(a.n2.CONNECTING,{adapter:a.rW.PHANTOM}),!this._wallet)throw a.Ty.notInstalled();if(this._wallet.isConnected)await this.connectWithProvider(this._wallet);else{const n=this._wallet._handleDisconnect;try{await new Promise(((i,e)=>{this._wallet?(this._wallet.once("connect",(async()=>{await this.connectWithProvider(this._wallet),i(this.provider)})),this._wallet._handleDisconnect=function(){e(a.Ty.windowClosed());for(var i=arguments.length,s=new Array(i),o=0;o<i;o++)s[o]=arguments[o];return n.apply(t._wallet,s)},this._wallet.connect().catch((t=>{e(t)}))):e(a.Ty.notInstalled())}))}catch(i){if(i instanceof a.up)throw i;throw a.RM.connectionError(null===i||void 0===i?void 0:i.message)}finally{this._wallet._handleDisconnect=n}}if(!this._wallet.publicKey)throw a.RM.connectionError();return this._wallet.on("disconnect",this._onDisconnect),this.provider}catch(i){throw this.status=a.MP.READY,this.rehydrated=!1,this.emit(a.n2.ERRORED,i),i}}async disconnect(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{cleanup:!1};await super.disconnectSession();try{var i;await(null===(i=this._wallet)||void 0===i?void 0:i.disconnect()),t.cleanup&&(this.status=a.MP.NOT_READY,this.phantomProvider=null,this._wallet=null),await super.disconnect()}catch(n){this.emit(a.n2.ERRORED,a.RM.disconnectionError(null===n||void 0===n?void 0:n.message))}}async getUserInfo(){if(!this.isWalletConnected)throw a.RM.notConnectedError("Not connected with wallet, Please login/connect first");return{}}async addChain(t){var i;let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.checkAddChainRequirements(t,n),null===(i=this.phantomProvider)||void 0===i||i.addChain(t),this.addChainConfig(t)}async switchChain(t){var i;let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.checkSwitchChainRequirements(t,n),await(null===(i=this.phantomProvider)||void 0===i?void 0:i.switchChain(t)),this.setAdapterSettings({chainConfig:this.getChainConfig(t.chainId)})}async connectWithProvider(t){if(!this.phantomProvider)throw a.RM.connectionError("No phantom provider");return await this.phantomProvider.setupProvider(t),this.status=a.MP.CONNECTED,this.emit(a.n2.CONNECTED,{adapter:a.rW.PHANTOM,reconnected:this.rehydrated}),this.provider}}}}]);
//# sourceMappingURL=392.affc9d65.chunk.js.map