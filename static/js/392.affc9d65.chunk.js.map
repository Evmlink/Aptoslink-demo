{"version":3,"file":"static/js/392.affc9d65.chunk.js","mappings":"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","sources":["../node_modules/@web3auth/phantom-adapter/src/utils.ts","../node_modules/@web3auth/phantom-adapter/src/phantomAdapter.ts"],"sourcesContent":["import type { IPhantomWalletProvider } from \"@web3auth/solana-provider\";\n\ndeclare global {\n  interface Window {\n    solana: IPhantomWalletProvider & { isPhantom: boolean };\n  }\n}\n\nexport function poll(callback: () => boolean | Promise<boolean>, interval: number, count: number): Promise<boolean> {\n  return new Promise((resolve, reject) => {\n    if (count > 0) {\n      setTimeout(async () => {\n        const done = await callback();\n        if (done) resolve(done);\n        if (!done)\n          poll(callback, interval, count - 1)\n            .then((res) => {\n              resolve(res);\n              return res;\n            })\n            .catch((err) => reject(err));\n      }, interval);\n    } else {\n      resolve(false);\n    }\n  });\n}\n\nexport const detectProvider = async (\n  options: { interval: number; count: number } = { interval: 1000, count: 3 }\n): Promise<IPhantomWalletProvider | null> => {\n  const isPhantomAvailable = typeof window !== \"undefined\" && !!window.solana?.isPhantom;\n  if (isPhantomAvailable) {\n    return window.solana;\n  }\n  const isAvailable = await poll(() => window.solana?.isPhantom, options.interval, options.count);\n  if (isAvailable) return window.solana;\n  return null;\n};\n","import {\n  ADAPTER_CATEGORY,\n  ADAPTER_CATEGORY_TYPE,\n  ADAPTER_EVENTS,\n  ADAPTER_NAMESPACES,\n  ADAPTER_STATUS,\n  ADAPTER_STATUS_TYPE,\n  AdapterInitOptions,\n  AdapterNamespaceType,\n  BaseAdapterSettings,\n  CHAIN_NAMESPACES,\n  ChainNamespaceType,\n  CONNECTED_EVENT_DATA,\n  CustomChainConfig,\n  IProvider,\n  log,\n  UserInfo,\n  WALLET_ADAPTERS,\n  WalletInitializationError,\n  WalletLoginError,\n  Web3AuthError,\n} from \"@web3auth/base\";\nimport { BaseSolanaAdapter } from \"@web3auth/base-solana-adapter\";\nimport { IPhantomWalletProvider, PhantomInjectedProvider } from \"@web3auth/solana-provider\";\n\nimport { detectProvider } from \"./utils\";\nexport type PhantomAdapterOptions = BaseAdapterSettings;\n\nexport class PhantomAdapter extends BaseSolanaAdapter<void> {\n  readonly name: string = WALLET_ADAPTERS.PHANTOM;\n\n  readonly adapterNamespace: AdapterNamespaceType = ADAPTER_NAMESPACES.SOLANA;\n\n  readonly currentChainNamespace: ChainNamespaceType = CHAIN_NAMESPACES.SOLANA;\n\n  readonly type: ADAPTER_CATEGORY_TYPE = ADAPTER_CATEGORY.EXTERNAL;\n\n  public status: ADAPTER_STATUS_TYPE = ADAPTER_STATUS.NOT_READY;\n\n  public _wallet: IPhantomWalletProvider | null = null;\n\n  private phantomProvider: PhantomInjectedProvider | null = null;\n\n  get isWalletConnected(): boolean {\n    return !!(this._wallet?.isConnected && this.status === ADAPTER_STATUS.CONNECTED);\n  }\n\n  get provider(): IProvider | null {\n    if (this.status !== ADAPTER_STATUS.NOT_READY && this.phantomProvider) {\n      return this.phantomProvider;\n    }\n    return null;\n  }\n\n  set provider(_: IProvider | null) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init(options: AdapterInitOptions = {}): Promise<void> {\n    await super.init(options);\n    super.checkInitializationRequirements();\n    this._wallet = await detectProvider({ interval: 500, count: 3 });\n    if (!this._wallet) throw WalletInitializationError.notInstalled();\n    this.phantomProvider = new PhantomInjectedProvider({ config: { chainConfig: this.chainConfig as CustomChainConfig } });\n    this.status = ADAPTER_STATUS.READY;\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.PHANTOM);\n\n    try {\n      log.debug(\"initializing phantom adapter\");\n      if (options.autoConnect) {\n        this.rehydrated = true;\n        await this.connect();\n      }\n    } catch (error) {\n      log.error(\"Failed to connect with cached phantom provider\", error);\n      this.emit(\"ERRORED\", error);\n    }\n  }\n\n  async connect(): Promise<IProvider | null> {\n    try {\n      super.checkConnectionRequirements();\n      this.status = ADAPTER_STATUS.CONNECTING;\n      this.emit(ADAPTER_EVENTS.CONNECTING, { adapter: WALLET_ADAPTERS.PHANTOM });\n\n      if (!this._wallet) throw WalletInitializationError.notInstalled();\n      if (!this._wallet.isConnected) {\n        const handleDisconnect = this._wallet._handleDisconnect;\n        try {\n          await new Promise<IProvider | null>((resolve, reject) => {\n            const connect = async () => {\n              await this.connectWithProvider(this._wallet as IPhantomWalletProvider);\n              resolve(this.provider);\n            };\n            if (!this._wallet) {\n              reject(WalletInitializationError.notInstalled());\n              return;\n            }\n            this._wallet.once(\"connect\", connect);\n            // Raise an issue on phantom that if window is closed, disconnect event is not fired\n            (this._wallet as IPhantomWalletProvider)._handleDisconnect = (...args: unknown[]) => {\n              reject(WalletInitializationError.windowClosed());\n              return handleDisconnect.apply(this._wallet, args);\n            };\n\n            this._wallet.connect().catch((reason: unknown) => {\n              reject(reason);\n            });\n          });\n        } catch (error: unknown) {\n          if (error instanceof Web3AuthError) throw error;\n          throw WalletLoginError.connectionError((error as Error)?.message);\n        } finally {\n          this._wallet._handleDisconnect = handleDisconnect;\n        }\n      } else {\n        await this.connectWithProvider(this._wallet);\n      }\n\n      if (!this._wallet.publicKey) throw WalletLoginError.connectionError();\n      this._wallet.on(\"disconnect\", this._onDisconnect);\n\n      return this.provider;\n    } catch (error: unknown) {\n      // ready again to be connected\n      this.status = ADAPTER_STATUS.READY;\n      this.rehydrated = false;\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\n      throw error;\n    }\n  }\n\n  async disconnect(options: { cleanup: boolean } = { cleanup: false }): Promise<void> {\n    await super.disconnectSession();\n    try {\n      await this._wallet?.disconnect();\n      if (options.cleanup) {\n        this.status = ADAPTER_STATUS.NOT_READY;\n        this.phantomProvider = null;\n        this._wallet = null;\n      }\n      await super.disconnect();\n    } catch (error: unknown) {\n      this.emit(ADAPTER_EVENTS.ERRORED, WalletLoginError.disconnectionError((error as Error)?.message));\n    }\n  }\n\n  async getUserInfo(): Promise<Partial<UserInfo>> {\n    if (!this.isWalletConnected) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    return {};\n  }\n\n  public async addChain(chainConfig: CustomChainConfig, init = false): Promise<void> {\n    super.checkAddChainRequirements(chainConfig, init);\n    this.phantomProvider?.addChain(chainConfig);\n    this.addChainConfig(chainConfig);\n  }\n\n  public async switchChain(params: { chainId: string }, init = false): Promise<void> {\n    super.checkSwitchChainRequirements(params, init);\n    await this.phantomProvider?.switchChain(params);\n    this.setAdapterSettings({ chainConfig: this.getChainConfig(params.chainId) as CustomChainConfig });\n  }\n\n  private async connectWithProvider(injectedProvider: IPhantomWalletProvider): Promise<IProvider | null> {\n    if (!this.phantomProvider) throw WalletLoginError.connectionError(\"No phantom provider\");\n    await this.phantomProvider.setupProvider(injectedProvider);\n    this.status = ADAPTER_STATUS.CONNECTED;\n    this.emit(ADAPTER_EVENTS.CONNECTED, { adapter: WALLET_ADAPTERS.PHANTOM, reconnected: this.rehydrated } as CONNECTED_EVENT_DATA);\n    return this.provider;\n  }\n\n  private _onDisconnect = () => {\n    if (this._wallet) {\n      this._wallet.off(\"disconnect\", this._onDisconnect);\n      this.rehydrated = false;\n      // ready to be connected again only if it was previously connected and not cleaned up\n      this.status = this.status === ADAPTER_STATUS.CONNECTED ? ADAPTER_STATUS.READY : ADAPTER_STATUS.NOT_READY;\n      this.emit(ADAPTER_EVENTS.DISCONNECTED);\n    }\n  };\n}\n"],"names":["poll","callback","interval","count","Promise","resolve","reject","setTimeout","async","done","then","res","catch","err","detectProvider","options","window","solana","_window$solana","isPhantom","_window$solana2","PhantomAdapter","BaseSolanaAdapter","constructor","_defineProperty","WALLET_ADAPTERS","ADAPTER_NAMESPACES","CHAIN_NAMESPACES","ADAPTER_CATEGORY","ADAPTER_STATUS","this","_wallet","off","_onDisconnect","rehydrated","status","emit","ADAPTER_EVENTS","isWalletConnected","_this$_wallet","isConnected","provider","phantomProvider","_","Error","super","init","checkInitializationRequirements","WalletInitializationError","PhantomInjectedProvider","config","chainConfig","log","autoConnect","connect","error","checkConnectionRequirements","adapter","connectWithProvider","handleDisconnect","_handleDisconnect","once","args","apply","_this","reason","Web3AuthError","WalletLoginError","message","publicKey","on","cleanup","disconnectSession","_this$_wallet2","disconnect","checkAddChainRequirements","_this$phantomProvider","addChain","addChainConfig","params","checkSwitchChainRequirements","_this$phantomProvider2","switchChain","setAdapterSettings","getChainConfig","chainId","injectedProvider","setupProvider","reconnected"],"sourceRoot":""}